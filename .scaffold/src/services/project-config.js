/**
 * Project Configuration service
 */
'use strict';

const Fs = require('fs');
const Path = require('path');
const Globby = require('globby');
const FancyLog = require('fancy-log');

const Yaml = require('js-yaml');
const AjvClass = require('ajv');
const Ajv = new AjvClass();

const BaseService = require('./base-service');

class ProjectConfig extends BaseService {
  constructor(injector) {
    super(injector);
    // console.log('CliParser Cnt.');

    // parse the package.json in root folder
    this.rootNpmPkgConfig = require(Path.join(this.cwd, 'package.json'));
    this.scaffoldConfig = this.rootNpmPkgConfig.scaffold;
  }

  // only get other service, dont call any method from them
  resolveDependencies() {
    super.resolveDependencies();
  }

  // do initial tasks
  initialize() {
    super.initialize();

    if (!this.cliParser) { return; }

    let projectName = this.cliParser.get('project');
    const getDefaultProject = () => {
      let defaultTarget = this.scaffoldConfig.projects.find((item) => item.default);
      defaultTarget = defaultTarget ? defaultTarget : this.scaffoldConfig.projects[0];
      return defaultTarget;
    };
    let config = getDefaultProject();
    projectName = projectName ? projectName : config.name;
    config = this.scaffoldConfig.projects.find((item) => (item.name === projectName));
    this.originConfig = config;

    let projectRootDir = config.rootDir;
    projectRootDir = Path.join(this.cwd, projectRootDir);
    this.projectNpmPkgConfig = require(Path.join(projectRootDir, 'package.json'));

    const hasScaffoldRootDir = (this.scaffoldConfig && this.scaffoldConfig.rootDir);
    const hasRootConfigDir = (this.scaffoldConfig && this.scaffoldConfig.configDir);
    const hasProjectConfigDir = (config && config.configDir);
    const hasProjectConfigFilesDir = (config && config.configFilesDir);

    let scaffoldDir = hasScaffoldRootDir ? this.scaffoldConfig.rootDir : './.scaffold';
    scaffoldDir = Path.join(process.cwd(), scaffoldDir);

    let rootConfigDir = hasRootConfigDir ? this.scaffoldConfig.configDir : './config';
    rootConfigDir = Path.join(process.cwd(), rootConfigDir);

    let projectConfigDir = hasProjectConfigDir ? config.configDir : './config';
    projectConfigDir = Path.join(projectRootDir, projectConfigDir);

    let projectConfigFilesDir = hasProjectConfigFilesDir ? config.configFilesDir : './config/project-configs';
    projectConfigFilesDir = Path.join(projectRootDir, projectConfigFilesDir);

    // project config files, accept json, json5 or yaml
    const configFiles = Globby.sync([
      `${projectConfigFilesDir}/**/*.y?(a)ml`
    ]);
    this.loger.logV(configFiles);

    let merged = {};
    try {
      for (const file of configFiles) {
        // this.loger.log(file);
        const fileContent = Fs.readFileSync(file, 'utf8');
        const config = Yaml.safeLoad(fileContent);
        merged = Object.assign({}, merged, config);
      }
    } catch (err) {
      throw err;
    }

    const headerJson = {
      $schema: `${Path.join(this.cwd, '.scaffold/config/project-config.schema.json')}`,
      description: 'This file is generated by tool. Do not modify it by manual. Change files under ./project-configs folder'
    };
    const info = {
      scaffoldDir: scaffoldDir,
      rootConfigDir: rootConfigDir,
      name: projectName,
      rootDir: projectRootDir,
      configDir: projectConfigDir
    };
    const mergedWithHeader = Object.assign({}, headerJson, info, merged);
    this.loger.logVV(JSON.stringify(mergedWithHeader, null, 2));

    // load schema in yaml and save to json file
    const schemaFile = Fs.readFileSync(`${scaffoldDir}/config/project-config.schema.yml`, 'utf8');
    const schema = Yaml.safeLoad(schemaFile);
    // save as json file
    Fs.writeFileSync(`${scaffoldDir}/config/project-config.schema.json`, JSON.stringify(schema, null, 2));

    // validate
    const isValid = Ajv.validate(schema, merged);
    this.loger.logV('Is project-config.json valid? ' + isValid);
    if (!isValid) {
      FancyLog.error(Ajv.errors);
      throw Error('Invalid project-config.json, please check config/project-configs/*.');
    }

    const resultConfig = mergedWithHeader;

    // write merged content into a json file, used by project
    if (!Fs.existsSync(projectConfigDir)) {
      Fs.mkdirSync(projectConfigDir);
    }
    Fs.writeFileSync(`${projectConfigDir}/project-config.json`, JSON.stringify(resultConfig, null, 2));

    // save
    this._config = resultConfig;
  }

  get config() { return this._config; }

  get packageName() { return this.projectNpmPkgConfig.name; }
  get packageVersion() { return this.projectNpmPkgConfig.version; }

  get scaffoldDir() { return this.config.scaffoldDir; }
  get rootConfigDir() { return this.config.rootConfigDir; }

  get name() { return this.config.name; }
  get rootDir() { return this.config.rootDir; }
  get originRootDir() { return this.originConfig.rootDir; }
  get configDir() { return this.config.configDir; }

  get srcDir() { return Path.join(this.cwd, this.config.folders.srcDir); }
  get libDir() { return Path.join(this.cwd, this.config.folders.libDir); }
  get mockDir() { return Path.join(this.cwd, this.config.folders.mockDir); }

  get distDir() { return Path.join(this.cwd, this.config.folders.distDir); }
  get publishDistDir() { return Path.join(this.cwd, this.config.folders.publishDistDir); }
  get bundleDistDir() { return Path.join(this.cwd, this.config.folders.bundleDistDir); }
  get reportDistDir() { return Path.join(this.cwd, this.config.folders.reportDistDir); }
  get apiDocDistDir() { return Path.join(this.cwd, this.config.folders.apiDocDistDir); }
  get documentDistDir() { return Path.join(this.cwd, this.config.folders.documentDistDir); }
}

module.exports = ProjectConfig;
